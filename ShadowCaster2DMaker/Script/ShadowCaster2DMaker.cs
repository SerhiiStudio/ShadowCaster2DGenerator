// Copyright(c) 2025 SerhiiStudio
// See LICENSE file for details

using System.Reflection;
using UnityEngine;
using UnityEngine.Rendering.Universal;
using System;
using System.Collections.Generic;


#if UNITY_EDITOR
using UnityEditor;
#endif


namespace SerhiiStudio
{
	public class ShadowCaster2DMaker : MonoBehaviour
	{
#if UNITY_EDITOR
		[SerializeField] private Sprite[] sprites;
		[SerializeField] private DefaultAsset folder;
		[SerializeField] private string targetFolderName;

		private List<GameObject> madeGameObjects;

		[SerializeField][HideInInspector] private bool doNotSaveToFolder;

		/// <summary>
		/// Main method to generate shadows
		/// </summary>
		public void GenerateShadows()
		{
			if (madeGameObjects == null || !doNotSaveToFolder)
			madeGameObjects = new List<GameObject>(); // If some unsaved objects are still on the scene but we should not save them. There will be no option to clear previous gameobjects using ClearMadeGameObjects

			foreach (var sprite in sprites)
			{
				var gameObj = InstantiateGo(sprite);
				DoShadow(sprite, gameObj);
				RefreshShadowCaster(gameObj);
			}

			if (!doNotSaveToFolder)
			{
				SaveAsGameObject(folder, targetFolderName, madeGameObjects);
				ClearMadeGameObjects();
			}

		}


		// Sets points to the shadow caster
		private void DoShadow(Sprite sprite, GameObject gameObj)
		{
			var caster = gameObj.GetComponent<ShadowCaster2D>();
			if (caster == null)
			{
				caster = gameObj.AddComponent<ShadowCaster2D>();
			}

			FieldInfo shapePathField = typeof(ShadowCaster2D).GetField("m_ShapePath", BindingFlags.NonPublic | BindingFlags.Instance);

			Vector3[] dinamicShape = MakePoints.GetPoints(sprite, transform);

			if (shapePathField != null)
			{
				shapePathField.SetValue(caster, dinamicShape);
			}
		}

		// Updates the shadow caster
		private void RefreshShadowCaster(GameObject gameObj)
		{
			var caster = gameObj.GetComponent<ShadowCaster2D>();
			if (caster == null)
			{
				Debug.LogWarning("ShadowCaster2D component not found on this GameObject.");
				return;
			}

			FieldInfo shapePathField = typeof(ShadowCaster2D).GetField("m_ShapePath", BindingFlags.NonPublic | BindingFlags.Instance);
			FieldInfo meshField = typeof(ShadowCaster2D).GetField("m_Mesh", BindingFlags.NonPublic | BindingFlags.Instance);

			Assembly universalRPAssembly = typeof(ShadowCaster2D).Assembly;

			Type shadowUtilityType = universalRPAssembly.GetType("UnityEngine.Rendering.Universal.ShadowUtility");

			MethodInfo generateShadowMeshMethod = null;
			if (shadowUtilityType != null)
			{
				generateShadowMeshMethod = shadowUtilityType.GetMethod("GenerateShadowMesh", BindingFlags.Public | BindingFlags.Static);
			}


			if (shapePathField == null || meshField == null || generateShadowMeshMethod == null)
			{
				Debug.LogError($"Failed to get ShadowCaster2D's internal fields or ShadowUtility.GenerateShadowMesh method via reflection. " +
							   $"ShapePath: {shapePathField != null}, Mesh: {meshField != null}, ShadowUtilityType: {shadowUtilityType != null}, GenerateShadowMesh: {generateShadowMeshMethod != null}");
				return;
			}

			meshField.SetValue(caster, new Mesh());

			Vector3[] currentShapePath = (Vector3[])shapePathField.GetValue(caster);

			generateShadowMeshMethod.Invoke(null, new object[] { meshField.GetValue(caster), currentShapePath });

			Debug.Log("ShadowCaster2D refreshed (mesh regenerated by ShadowUtility).");
		}

		// Calls the save mehod
		private void SaveAsGameObject(DefaultAsset folder, string targetFolderName, List<GameObject> objects)
		{
			SaveToFolder.Save(folder, targetFolderName, objects);
		}

		// Creates GO on the scene
		private GameObject InstantiateGo(UnityEngine.Object obj)
		{
			string goName = "Shadow_" + obj.name;

			GameObject go = new GameObject(goName);
			Undo.RegisterCreatedObjectUndo(go, $"created {goName}");
			Undo.SetTransformParent(go.transform, transform, "Reparent"); // If we don't save(so after ve remove gos) then we leave as child transform

			Undo.RecordObject(go, "Clear position");
			go.transform.localPosition = Vector3.zero;

			EditorUtility.SetDirty(go.transform);

			madeGameObjects.Add(go);

			return go;
		}

		/// <summary>
		/// Removes gameobjects from the scene if they were saves as prefabs
		/// If not - call it in editor separately
		/// </summary>
		public void ClearMadeGameObjects()
		{
			if (madeGameObjects != null)
				foreach (GameObject go in madeGameObjects)
					if (go != null)
						Undo.DestroyObjectImmediate(go);
			madeGameObjects.Clear();
		}
#endif
	}
}
